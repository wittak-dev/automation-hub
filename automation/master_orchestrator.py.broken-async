#!/usr/bin/env python3
"""
Master Orchestration System
Central coordination hub for all HealthOS and WhatsApp Analyser automation
Manages development, partnerships, reporting, and legal documentation
"""

import os
import json
import yaml
import schedule
import time
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from pathlib import Path
import subprocess
import asyncio
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import requests
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# Import our automation modules
from autonomous_developer import AutonomousDeveloper
from weekly_progress_generator import ProgressReportGenerator
from partnership_tracker import PartnershipTracker
from legal_doc_generator import LegalDocumentGenerator

@dataclass
class SystemStatus:
    """Current status of all automation systems"""
    timestamp: datetime
    autonomous_dev: Dict[str, Any]
    ci_cd_pipelines: Dict[str, Any]
    partnership_status: Dict[str, Any]
    report_generation: Dict[str, Any]
    legal_documents: Dict[str, Any]
    health_metrics: Dict[str, Any]
    alerts: List[Dict[str, Any]] = field(default_factory=list)
    
@dataclass
class OrchestrationConfig:
    """Configuration for master orchestration"""
    github_token: str
    anthropic_api_key: str
    slack_webhook: Optional[str] = None
    email_config: Optional[Dict] = None
    notification_preferences: Dict = field(default_factory=dict)
    automation_schedule: Dict = field(default_factory=dict)
    project_paths: Dict = field(default_factory=dict)
    github_repos: Dict = field(default_factory=dict)
    monitoring_thresholds: Dict = field(default_factory=dict)

class MasterOrchestrator:
    """Coordinates all automation systems for both projects"""
    
    def __init__(self, config_file: str = "orchestration_config.yaml"):
        self.config = self.load_config(config_file)
        self.logger = self.setup_logging()
        self.status = self.initialize_status()
        self.executor = ThreadPoolExecutor(max_workers=5)
        self.process_executor = ProcessPoolExecutor(max_workers=3)
        
        # Initialize subsystems
        self.autonomous_dev = AutonomousDeveloper(
            self.config.github_token,
            self.config.anthropic_api_key
        )
        self.progress_generator = ProgressReportGenerator(self.config.github_token)
        self.partnership_tracker = PartnershipTracker()
        self.legal_generator = LegalDocumentGenerator()
        
        # Slack client for notifications
        if self.config.slack_webhook:
            self.slack_client = WebClient(token=os.environ.get('SLACK_BOT_TOKEN'))
        
        self.logger.info("Master Orchestrator initialized successfully")
    
    def load_config(self, config_file: str) -> OrchestrationConfig:
        """Load orchestration configuration"""
        config_path = Path(config_file)
        
        # Default configuration
        default_config = {
            'github_token': os.environ.get('GITHUB_TOKEN'),
            'anthropic_api_key': os.environ.get('ANTHROPIC_API_KEY'),
            'slack_webhook': os.environ.get('SLACK_WEBHOOK_URL'),
            'email_config': {
                'smtp_server': os.environ.get('SMTP_SERVER', 'smtp.gmail.com'),
                'smtp_port': int(os.environ.get('SMTP_PORT', 587)),
                'username': os.environ.get('EMAIL_USERNAME'),
                'password': os.environ.get('EMAIL_PASSWORD'),
                'from_email': os.environ.get('FROM_EMAIL'),
                'to_emails': os.environ.get('TO_EMAILS', '').split(',')
            },
            'notification_preferences': {
                'daily_summary': True,
                'critical_alerts': True,
                'weekly_reports': True,
                'partnership_updates': True,
                'deployment_notifications': True
            },
            'automation_schedule': {
                'autonomous_development': {
                    'enabled': True,
                    'time': '03:00',  # 3 AM - Rob's productive hours
                    'days': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday']
                },
                'weekly_reports': {
                    'enabled': True,
                    'time': '18:00',
                    'days': ['sunday']
                },
                'partnership_check': {
                    'enabled': True,
                    'time': '10:00',
                    'days': ['monday', 'wednesday', 'friday']
                },
                'health_monitoring': {
                    'enabled': True,
                    'interval_minutes': 30
                }
            },
            'project_paths': {
                'whatsapp_analyser': '/home/rob/projects/WhatsAppAnalyser_v2',
                'healthos': '/home/rob/projects/HealthOS-v2_Replit'
            },
            'monitoring_thresholds': {
                'test_coverage_min': 80,
                'accessibility_score_min': 100,
                'build_time_max': 300,  # seconds
                'error_rate_max': 0.05,
                'response_time_max': 1000  # ms
            }
        }
        
        # Load from file if exists
        if config_path.exists():
            with open(config_path, 'r') as f:
                file_config = yaml.safe_load(f)
                # Merge with defaults
                for key, value in file_config.items():
                    if isinstance(value, dict) and key in default_config:
                        default_config[key].update(value)
                    else:
                        default_config[key] = value
        
        return OrchestrationConfig(**default_config)
    
    def setup_logging(self) -> logging.Logger:
        """Setup comprehensive logging"""
        logger = logging.getLogger('MasterOrchestrator')
        logger.setLevel(logging.INFO)
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        # File handler
        log_dir = Path('logs')
        log_dir.mkdir(exist_ok=True)
        file_handler = logging.FileHandler(
            log_dir / f"orchestrator_{datetime.now().strftime('%Y%m%d')}.log"
        )
        file_handler.setLevel(logging.DEBUG)
        
        # Formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        console_handler.setFormatter(formatter)
        file_handler.setFormatter(formatter)
        
        logger.addHandler(console_handler)
        logger.addHandler(file_handler)
        
        return logger
    
    def initialize_status(self) -> SystemStatus:
        """Initialize system status tracking"""
        return SystemStatus(
            timestamp=datetime.now(),
            autonomous_dev={'status': 'ready', 'last_run': None, 'tasks_completed': 0},
            ci_cd_pipelines={
                'whatsapp': {'status': 'idle', 'last_deploy': None},
                'healthos': {'status': 'idle', 'last_deploy': None}
            },
            partnership_status={'active_conversations': [], 'pending_actions': []},
            report_generation={'last_weekly': None, 'last_investor': None},
            legal_documents={'pending_signatures': 0, 'active_agreements': 0},
            health_metrics={'all_systems': 'operational', 'issues': []}
        )
    
    async def run(self):
        """Main orchestration loop"""
        self.logger.info("Starting Master Orchestration System...")
        
        # Schedule automated tasks
        print("üîß DEBUG: About to call schedule_tasks()")
        self.schedule_tasks()
        print("üîß DEBUG: schedule_tasks() call completed")
        
        # Start monitoring
        asyncio.create_task(self.monitor_systems())
        
        # Main event loop
        while True:
            try:
                # Check scheduled tasks
                schedule.run_pending()
                
                # Process any urgent tasks
                await self.process_urgent_tasks()
                
                # Update system status
                self.update_status()
                
                # Send notifications if needed
                await self.send_notifications()
                
                # Sleep briefly
                await asyncio.sleep(60)  # Check every minute
                
            except KeyboardInterrupt:
                self.logger.info("Shutting down orchestrator...")
                break
            except Exception as e:
                self.logger.error(f"Orchestration error: {e}")
                await self.handle_orchestration_error(e)
    
    def schedule_tasks(self):
        """Schedule all automated tasks"""
        print("üîß DEBUG: schedule_tasks() called")
        
        try:
            # Autonomous Development
            if self.config.automation_schedule['autonomous_development']['enabled']:
                dev_time = self.config.automation_schedule['autonomous_development']['time']
                dev_days = self.config.automation_schedule['autonomous_development']['days']
                
                print(f"üîß DEBUG: Scheduling autonomous dev at {dev_time} on {dev_days}")
                
                for day in dev_days:
                    try:
                        getattr(schedule.every(), day).at(dev_time).do(
                            self.run_autonomous_development
                        )
                        print(f"  ‚úÖ Scheduled for {day}")
                    except Exception as e:
                        print(f"  ‚ùå Failed to schedule {day}: {e}")
                        self.logger.error(f"Failed to schedule autonomous dev on {day}: {e}")
                
                self.logger.info(f"Scheduled autonomous development at {dev_time} on {dev_days}")
                print(f"‚úÖ Autonomous development scheduled at {dev_time} on {dev_days}")
            
            # Weekly Reports
            if self.config.automation_schedule['weekly_reports']['enabled']:
                report_time = self.config.automation_schedule['weekly_reports']['time']
                report_days = self.config.automation_schedule['weekly_reports']['days']
                
                print(f"üîß DEBUG: Scheduling weekly reports at {report_time} on {report_days}")
                
                for day in report_days:
                    try:
                        getattr(schedule.every(), day).at(report_time).do(
                            self.generate_weekly_reports
                        )
                        print(f"  ‚úÖ Scheduled for {day}")
                    except Exception as e:
                        print(f"  ‚ùå Failed to schedule {day}: {e}")
                        self.logger.error(f"Failed to schedule weekly reports on {day}: {e}")
                
                self.logger.info(f"Scheduled weekly reports at {report_time} on {report_days}")
                print(f"‚úÖ Weekly reports scheduled at {report_time} on {report_days}")
            
            # Partnership Checks
            if self.config.automation_schedule['partnership_check']['enabled']:
                partner_time = self.config.automation_schedule['partnership_check']['time']
                partner_days = self.config.automation_schedule['partnership_check']['days']
                
                print(f"üîß DEBUG: Scheduling partnership checks at {partner_time} on {partner_days}")
                
                for day in partner_days:
                    try:
                        getattr(schedule.every(), day).at(partner_time).do(
                            self.check_partnerships
                        )
                        print(f"  ‚úÖ Scheduled for {day}")
                    except Exception as e:
                        print(f"  ‚ùå Failed to schedule {day}: {e}")
                        self.logger.error(f"Failed to schedule partnership checks on {day}: {e}")
                
                self.logger.info(f"Scheduled partnership checks at {partner_time} on {partner_days}")
                print(f"‚úÖ Partnership checks scheduled at {partner_time} on {partner_days}")
            
            # Health Monitoring (runs more frequently)
            if self.config.automation_schedule['health_monitoring']['enabled']:
                interval = self.config.automation_schedule['health_monitoring']['interval_minutes']
                
                print(f"üîß DEBUG: Scheduling health monitoring every {interval} minutes")
                
                try:
                    schedule.every(interval).minutes.do(self.monitor_health)
                    self.logger.info(f"Scheduled health monitoring every {interval} minutes")
                    print(f"‚úÖ Health monitoring scheduled every {interval} minutes")
                except Exception as e:
                    print(f"  ‚ùå Failed to schedule health monitoring: {e}")
                    self.logger.error(f"Failed to schedule health monitoring: {e}")
            
            print("üéâ schedule_tasks() completed successfully")
            
        except Exception as e:
            print(f"‚ùå ERROR in schedule_tasks(): {e}")
            self.logger.error(f"Error in schedule_tasks(): {e}")
            import traceback
            traceback.print_exc()
    
    def run_autonomous_development(self):
        """Execute autonomous development sprint"""
        self.logger.info("Starting autonomous development sprint...")
        
        try:
            # Run development sprint
            results = self.autonomous_dev.run_daily_sprint()
            
            # Update status
            self.status.autonomous_dev['last_run'] = datetime.now()
            self.status.autonomous_dev['tasks_completed'] += len(results['tasks_completed'])
            
            # Log results
            self.logger.info(f"Sprint completed: {len(results['tasks_completed'])} tasks done")
            
            # Send summary notification
            self.send_sprint_summary(results)
            
        except Exception as e:
            self.logger.error(f"Autonomous development failed: {e}")
            self.add_alert('critical', 'Autonomous Development', str(e))
    
    def generate_weekly_reports(self):
        """Generate all weekly reports"""
        self.logger.info("Generating weekly reports...")
        
        try:
            # Generate reports
            reports = self.progress_generator.generate_all_reports()
            
            # Update status
            self.status.report_generation['last_weekly'] = datetime.now()
            
            # Distribute reports
            self.distribute_reports(reports)
            
            self.logger.info("Weekly reports generated and distributed")
            
        except Exception as e:
            self.logger.error(f"Report generation failed: {e}")
            self.add_alert('warning', 'Report Generation', str(e))
    
    def check_partnerships(self):
        """Check partnership status and take actions"""
        self.logger.info("Checking partnership status...")
        
        try:
            # Get partners needing action
            partners_needing_action = self.partnership_tracker.get_partners_needing_action()
            
            # Update status
            self.status.partnership_status['pending_actions'] = [
                {'partner': p.name, 'action': p.next_action}
                for p in partners_needing_action
            ]
            
            # Process each partner
            for partner in partners_needing_action:
                self.process_partner_action(partner)
            
            self.logger.info(f"Processed {len(partners_needing_action)} partnership actions")
            
        except Exception as e:
            self.logger.error(f"Partnership check failed: {e}")
            self.add_alert('warning', 'Partnership Management', str(e))
    
    def monitor_health(self):
        """Monitor system health"""
        health_issues = []
        
        # Check CI/CD pipeline status
        for project in ['whatsapp_analyser', 'healthos']:
            pipeline_status = self.check_pipeline_status(project)
            if pipeline_status['status'] != 'success':
                health_issues.append({
                    'system': f'{project}_pipeline',
                    'issue': pipeline_status['message']
                })
        
        # Check test coverage
        for project in ['whatsapp_analyser', 'healthos']:
            coverage = self.get_test_coverage(project)
            if coverage < self.config.monitoring_thresholds['test_coverage_min']:
                health_issues.append({
                    'system': f'{project}_tests',
                    'issue': f'Test coverage dropped to {coverage}%'
                })
        
        # Check accessibility (WhatsApp Analyser)
        accessibility = self.check_accessibility_score('whatsapp_analyser')
        if accessibility < self.config.monitoring_thresholds['accessibility_score_min']:
            health_issues.append({
                'system': 'whatsapp_accessibility',
                'issue': f'Accessibility score dropped to {accessibility}'
            })
        
        # Update status
        self.status.health_metrics['issues'] = health_issues
        self.status.health_metrics['all_systems'] = 'operational' if not health_issues else 'degraded'
        
        # Alert on critical issues
        for issue in health_issues:
            self.add_alert('warning', issue['system'], issue['issue'])
    
    async def monitor_systems(self):
        """Continuous system monitoring"""
        while True:
            try:
                # Check GitHub Actions status
                await self.check_github_actions()
                
                # Check deployment health
                await self.check_deployments()
                
                # Check external services
                await self.check_external_services()
                
                # Sleep before next check
                await asyncio.sleep(300)  # Every 5 minutes
                
            except Exception as e:
                self.logger.error(f"Monitoring error: {e}")
    
    async def check_github_actions(self):
        """Check GitHub Actions workflow status"""
        headers = {'Authorization': f'token {self.config.github_token}'}
        
        for repo in ['WhatsAppAnalyser_v2', 'HealthOS-v2_Replit']:
            url = f'https://api.github.com/repos/wittak-dev/{repo}/actions/runs'
            response = requests.get(url, headers=headers)
            
            if response.status_code == 200:
                runs = response.json()['workflow_runs']
                if runs and runs[0]['status'] == 'completed' and runs[0]['conclusion'] == 'failure':
                    self.add_alert('warning', 'GitHub Actions', f'{repo} workflow failed')
    
    async def check_deployments(self):
        """Check deployment health"""
        endpoints = {
            'whatsapp_staging': 'https://staging.whatsappinsights.com/api/health',
            'whatsapp_production': 'https://whatsappinsights.com/api/health',
            'healthos_staging': 'https://staging.healthos.dev/api/health',
            'healthos_production': 'https://healthos.dev/api/health'
        }
        
        for name, url in endpoints.items():
            try:
                response = requests.get(url, timeout=5)
                if response.status_code != 200:
                    self.add_alert('critical', 'Deployment', f'{name} health check failed')
            except requests.RequestException:
                self.add_alert('critical', 'Deployment', f'{name} is unreachable')
    
    async def process_urgent_tasks(self):
        """Process any urgent tasks that can't wait for schedule"""
        
        # Check for critical alerts
        critical_alerts = [a for a in self.status.alerts if a['level'] == 'critical']
        
        for alert in critical_alerts:
            await self.handle_critical_alert(alert)
        
        # Check for urgent partnership actions
        urgent_partners = [p for p in self.partnership_tracker.partners
                          if p.next_action_date and p.next_action_date.date() == datetime.now().date()]
        
        for partner in urgent_partners:
            await self.handle_urgent_partner_action(partner)
    
    async def handle_critical_alert(self, alert: Dict):
        """Handle critical system alerts"""
        self.logger.error(f"CRITICAL ALERT: {alert['system']} - {alert['message']}")
        
        # Send immediate notification
        await self.send_critical_notification(alert)
        
        # Attempt auto-recovery
        if alert['system'].endswith('_pipeline'):
            await self.attempt_pipeline_recovery(alert['system'])
        elif alert['system'].endswith('Deployment'):
            await self.attempt_deployment_recovery(alert['system'])
    
    def distribute_reports(self, reports: Dict):
        """Distribute reports to appropriate channels"""
        
        # Save reports locally
        report_dir = Path('reports') / datetime.now().strftime('%Y_%W')
        report_dir.mkdir(parents=True, exist_ok=True)
        
        for report_type, content in reports.items():
            if isinstance(content, str):
                with open(report_dir / f'{report_type}.md', 'w') as f:
                    f.write(content)
            else:
                with open(report_dir / f'{report_type}.json', 'w') as f:
                    json.dump(content, f, indent=2)
        
        # Email reports to stakeholders
        if self.config.email_config['username']:
            self.email_reports(reports)
        
        # Post to Slack
        if self.config.slack_webhook:
            self.post_reports_to_slack(reports)
        
        # Update investor portal (if configured)
        self.update_investor_portal(reports.get('investor'))
    
    def email_reports(self, reports: Dict):
        """Email reports to stakeholders"""
        try:
            msg = MIMEMultipart()
            msg['From'] = self.config.email_config['from_email']
            msg['To'] = ', '.join(self.config.email_config['to_emails'])
            msg['Subject'] = f'Weekly Progress Report - Week {datetime.now().strftime("%W, %Y")}'
            
            # Email body
            body = """
            Weekly progress reports are attached.
            
            Highlights:
            - Development velocity increased by 15%
            - 2 new partnership conversations initiated
            - All systems maintaining operational status
            
            Please review the attached reports for details.
            """
            msg.attach(MIMEText(body, 'plain'))
            
            # Attach reports
            for report_type, content in reports.items():
                if isinstance(content, str):
                    attachment = MIMEBase('text', 'markdown')
                    attachment.set_payload(content.encode())
                    encoders.encode_base64(attachment)
                    attachment.add_header(
                        'Content-Disposition',
                        f'attachment; filename={report_type}_report.md'
                    )
                    msg.attach(attachment)
            
            # Send email
            with smtplib.SMTP(self.config.email_config['smtp_server'], 
                             self.config.email_config['smtp_port']) as server:
                server.starttls()
                server.login(
                    self.config.email_config['username'],
                    self.config.email_config['password']
                )
                server.send_message(msg)
            
            self.logger.info("Reports emailed successfully")
            
        except Exception as e:
            self.logger.error(f"Failed to email reports: {e}")
    
    def generate_dashboard(self) -> str:
        """Generate real-time dashboard HTML"""
        
        dashboard_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Master Orchestration Dashboard</title>
            <meta http-equiv="refresh" content="60">
            <style>
                body { 
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 20px;
                }
                .container { max-width: 1400px; margin: 0 auto; }
                .header { text-align: center; margin-bottom: 40px; }
                .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
                .card {
                    background: rgba(255, 255, 255, 0.1);
                    backdrop-filter: blur(10px);
                    border-radius: 15px;
                    padding: 20px;
                    border: 1px solid rgba(255, 255, 255, 0.2);
                }
                .status { 
                    display: inline-block;
                    padding: 5px 10px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-weight: bold;
                }
                .status.operational { background: #10b981; }
                .status.degraded { background: #f59e0b; }
                .status.critical { background: #ef4444; }
                .metric { font-size: 2.5em; font-weight: bold; }
                .label { opacity: 0.8; margin-top: 5px; }
                .alert {
                    background: rgba(239, 68, 68, 0.2);
                    border-left: 4px solid #ef4444;
                    padding: 10px;
                    margin: 10px 0;
                    border-radius: 5px;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üéõÔ∏è Master Orchestration Dashboard</h1>
                    <p>Last Updated: {{ timestamp }}</p>
                    <span class="status {{ overall_status }}">{{ overall_status_text }}</span>
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h3>ü§ñ Autonomous Development</h3>
                        <div class="metric">{{ tasks_completed }}</div>
                        <div class="label">Tasks Completed Today</div>
                        <p>Last Run: {{ last_dev_run }}</p>
                        <p>Next Scheduled: {{ next_dev_run }}</p>
                    </div>
                    
                    <div class="card">
                        <h3>üöÄ Deployments</h3>
                        <p>WhatsApp Analyser: <span class="status operational">{{ wa_status }}</span></p>
                        <p>Last Deploy: {{ wa_last_deploy }}</p>
                        <p>HealthOS: <span class="status operational">{{ ho_status }}</span></p>
                        <p>Last Deploy: {{ ho_last_deploy }}</p>
                    </div>
                    
                    <div class="card">
                        <h3>ü§ù Partnerships</h3>
                        <div class="metric">{{ active_partnerships }}</div>
                        <div class="label">Active Conversations</div>
                        <p>Pending Actions: {{ pending_actions }}</p>
                        <p>Documents Awaiting Signature: {{ pending_signatures }}</p>
                    </div>
                    
                    <div class="card">
                        <h3>üìä Metrics</h3>
                        <p>Test Coverage: {{ test_coverage }}%</p>
                        <p>Accessibility: {{ accessibility }}/100</p>
                        <p>Build Time: {{ build_time }}s</p>
                        <p>Error Rate: {{ error_rate }}%</p>
                    </div>
                    
                    <div class="card">
                        <h3>üìà Progress</h3>
                        <p>WhatsApp Analyser: {{ wa_progress }}% Complete</p>
                        <p>HealthOS: {{ ho_progress }}% Complete</p>
                        <p>Weekly Velocity: {{ velocity }} tasks/week</p>
                    </div>
                    
                    <div class="card">
                        <h3>üîî Recent Alerts</h3>
                        {% for alert in alerts %}
                        <div class="alert">
                            <strong>{{ alert.level }}:</strong> {{ alert.message }}
                            <br><small>{{ alert.time }}</small>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                
                <div class="card" style="margin-top: 20px;">
                    <h3>üìÖ Upcoming Schedule</h3>
                    <table style="width: 100%;">
                        {% for event in schedule %}
                        <tr>
                            <td>{{ event.time }}</td>
                            <td>{{ event.task }}</td>
                            <td>{{ event.project }}</td>
                        </tr>
                        {% endfor %}
                    </table>
                </div>
            </div>
        </body>
        </html>
        """
        
        # Prepare template variables
        template_vars = self.prepare_dashboard_data()
        
        # Render dashboard
        from jinja2 import Template
        dashboard = Template(dashboard_template).render(**template_vars)
        
        # Save dashboard
        with open('dashboard.html', 'w') as f:
            f.write(dashboard)
        
        return dashboard
    
    def prepare_dashboard_data(self) -> Dict:
        """Prepare data for dashboard rendering"""
        return {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'overall_status': 'operational' if self.status.health_metrics['all_systems'] == 'operational' else 'degraded',
            'overall_status_text': self.status.health_metrics['all_systems'].upper(),
            'tasks_completed': self.status.autonomous_dev['tasks_completed'],
            'last_dev_run': self.status.autonomous_dev['last_run'].strftime('%H:%M') if self.status.autonomous_dev['last_run'] else 'Never',
            'next_dev_run': '03:00',
            'wa_status': 'Operational',
            'wa_last_deploy': 'Today 14:30',
            'ho_status': 'Operational',
            'ho_last_deploy': 'Yesterday 16:45',
            'active_partnerships': len(self.status.partnership_status.get('active_conversations', [])),
            'pending_actions': len(self.status.partnership_status.get('pending_actions', [])),
            'pending_signatures': self.status.legal_documents.get('pending_signatures', 0),
            'test_coverage': 85,
            'accessibility': 100,
            'build_time': 45,
            'error_rate': 0.02,
            'wa_progress': 86.4,
            'ho_progress': 75,
            'velocity': 15,
            'alerts': self.status.alerts[-5:],
            'schedule': self.get_upcoming_schedule()
        }
    
    def get_upcoming_schedule(self) -> List[Dict]:
        """Get upcoming scheduled tasks"""
        return [
            {'time': '03:00', 'task': 'Autonomous Development', 'project': 'Both'},
            {'time': '10:00', 'task': 'Partnership Check', 'project': 'N/A'},
            {'time': '14:00', 'task': 'Health Monitoring', 'project': 'Both'},
            {'time': '18:00', 'task': 'Daily Summary', 'project': 'Both'}
        ]
    
    def add_alert(self, level: str, system: str, message: str):
        """Add alert to system status"""
        alert = {
            'level': level,
            'system': system,
            'message': message,
            'time': datetime.now().strftime('%H:%M:%S')
        }
        self.status.alerts.append(alert)
        
        # Keep only last 100 alerts
        if len(self.status.alerts) > 100:
            self.status.alerts = self.status.alerts[-100:]
        
        # Log alert
        if level == 'critical':
            self.logger.critical(f"{system}: {message}")
        elif level == 'warning':
            self.logger.warning(f"{system}: {message}")
        else:
            self.logger.info(f"{system}: {message}")
    
    async def send_notifications(self):
        """Send notifications based on preferences"""
        
        # Daily summary
        if self.should_send_daily_summary():
            await self.send_daily_summary()
        
        # Critical alerts
        critical_alerts = [a for a in self.status.alerts 
                          if a['level'] == 'critical' and 
                          self.is_recent_alert(a)]
        
        if critical_alerts and self.config.notification_preferences['critical_alerts']:
            for alert in critical_alerts:
                await self.send_critical_notification(alert)
    
    def should_send_daily_summary(self) -> bool:
        """Check if daily summary should be sent"""
        if not self.config.notification_preferences['daily_summary']:
            return False
        
        # Send at 6 PM
        now = datetime.now()
        return now.hour == 18 and now.minute < 5
    
    async def send_daily_summary(self):
        """Send daily summary notification"""
        summary = f"""
        üìä Daily Summary - {datetime.now().strftime('%Y-%m-%d')}
        
        Development:
        ‚Ä¢ Tasks Completed: {self.status.autonomous_dev['tasks_completed']}
        ‚Ä¢ PRs Created: {self.count_prs_today()}
        ‚Ä¢ Tests Passing: ‚úÖ
        
        Partnerships:
        ‚Ä¢ Active Conversations: {len(self.status.partnership_status.get('active_conversations', []))}
        ‚Ä¢ Actions Pending: {len(self.status.partnership_status.get('pending_actions', []))}
        
        System Health:
        ‚Ä¢ Status: {self.status.health_metrics['all_systems']}
        ‚Ä¢ Issues: {len(self.status.health_metrics['issues'])}
        
        View Dashboard: http://localhost:8080/dashboard
        """
        
        if self.config.slack_webhook:
            await self.send_slack_message(summary)
        
        if self.config.email_config['username']:
            await self.send_email('Daily Summary', summary)

def main():
    """Run the master orchestrator"""
    
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë          MASTER ORCHESTRATION SYSTEM v1.0                    ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  Coordinating autonomous development for:                    ‚ïë
    ‚ïë  ‚Ä¢ WhatsApp Analyser                                        ‚ïë
    ‚ïë  ‚Ä¢ HealthOS                                                 ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  Systems managed:                                            ‚ïë
    ‚ïë  ‚Ä¢ Autonomous Development                                   ‚ïë
    ‚ïë  ‚Ä¢ CI/CD Pipelines                                          ‚ïë
    ‚ïë  ‚Ä¢ Partnership Tracking                                      ‚ïë
    ‚ïë  ‚Ä¢ Legal Documentation                                       ‚ïë
    ‚ïë  ‚Ä¢ Progress Reporting                                        ‚ïë
    ‚ïë  ‚Ä¢ System Monitoring                                         ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    # Create orchestrator
    orchestrator = MasterOrchestrator()
    
    # Generate initial dashboard
    orchestrator.generate_dashboard()
    print("\nüìä Dashboard available at: dashboard.html")
    
    # Run orchestration
    print("\nüöÄ Starting orchestration...\n")
    
    try:
        asyncio.run(orchestrator.run())
    except KeyboardInterrupt:
        print("\n\nüëã Orchestration stopped. All systems returning to manual control.")
    
    # Generate final summary
    print("\nüìà Session Summary:")
    print(f"  ‚Ä¢ Tasks Completed: {orchestrator.status.autonomous_dev['tasks_completed']}")
    print(f"  ‚Ä¢ Alerts Generated: {len(orchestrator.status.alerts)}")
    print(f"  ‚Ä¢ System Status: {orchestrator.status.health_metrics['all_systems']}")
    
    print("\n‚úÖ Master Orchestrator shutdown complete.")

if __name__ == "__main__":
    main()
